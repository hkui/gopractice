/**
在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。

缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。
内置的 cap 函数可以返回缓冲区的容量。
 */

/*
如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。
如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功
 */
package main

import "fmt"

func sum(ch chan int,i int )  {
	var (
		j=0

	)
	for ;j<i;j++{
		ch<-j
	}

}

func main()  {

	ch:=make(chan int,5)
	go sum(ch,5)

	for i:=0;i<cap(ch);i++  {

		fmt.Println(<-ch)
	}



}
